<!DOCTYPE html>
<html class="w-full h-full">

<head>
  <title>Structured Generation Visualized - Floneum Blog</title>
  <meta name="description" content="Floneum is a graph editor for local LLM workflows." />
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta charset="UTF-8" />
  <style>
    .markdown-body ul {
      list-style: disc;
    }

    .markdown-body ol {
      list-style: decimal;
    }

    .markdown-body li {
      display: list-item;
    }

    .markdown-body button {
      display: inline-block;
      background-color: rgba(209, 213, 219, 0.3);
      border-radius: 0.25rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid;
      margin: 0.25rem;
    }

    .markdown-body .header {
      color: inherit
    }

    .markdown-body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 5%;
      /* padding: 45px; */
      list-style: disc;
    }

    .main::-webkit-scrollbar {
      display: none;
    }

    /* Hide scrollbar for IE, Edge and Firefox */
    .main {
      -ms-overflow-style: none;
      /* IE and Edge */
      scrollbar-width: none;
      /* Firefox */
    }
  </style>
  <script src="https://buttons.github.io/buttons.js"></script>
<link rel="preload" href="/./assets/dioxus/floneum-site_bg.wasm" as="fetch" type="application/wasm" crossorigin="">
            <link rel="preload" href="/./assets/dioxus/floneum-site.js" as="script">
            <link rel="stylesheet" href="/outputcss13510405c54376df.css"/><link rel="stylesheet" href="/githubmarkdownlightmincss8afc7de0f4421337.css"/><link rel="icon" href="/Iconpng4588fb7843cca493.avif" type="image/png"/><link rel="stylesheet" href="/loadingcssc7b5459b9da4071e.css"/></head>

<body style="overflow-x:hidden;--scroll:0;" class="w-full h-full">
  <div id="main" class="w-full h-full"><script>window.hydrate_queue=[];window.dx_hydrate=(id,data)=>{const decoded=atob(data),bytes=Uint8Array.from(decoded,(c)=>c.charCodeAt(0));if(window.hydration_callback)window.hydration_callback(id,bytes);else window.hydrate_queue.push([id,bytes])};
</script><!--placeholder0--><!--placeholder1--><!--placeholder2--><!--placeholder3--><nav class="bg-white shadow" data-node-hydration="4"><div class="mx-auto max-w-7xl px-2 sm:px-4 lg:px-8"><div class="flex h-16 justify-between"><div class="flex px-2 lg:px-0"><div class="flex flex-shrink-0 items-center"><a href="/" dioxus-prevent-default="onclick" class="text-xl m-2 md:mr-12 flex flex-row items-center" data-node-hydration="5,click:1"><img src="/Iconpng4588fb7843cca493.avif" class="h-8 w-8 mx-2" alt="Floneum" data-node-hydration="6"/><!--node-id7-->Floneum<!--#--></a></div><div class="hidden lg:ml-6 lg:flex lg:space-x-8"><a href="/" dioxus-prevent-default="onclick" class="inline-flex items-center border-b-2 border-transparent px-1 pt-1 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700" data-node-hydration="8,click:1"><!--node-id9-->Home<!--#--></a><a href="/docs/" dioxus-prevent-default="onclick" class="inline-flex items-center border-b-2 border-transparent px-1 pt-1 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700" data-node-hydration="10,click:1"><!--node-id11-->Docs<!--#--></a></div></div><div class="flex flex-1 items-center justify-center px-2 lg:ml-6 lg:justify-end"><div class="w-full max-w-lg lg:max-w-xs"><label for="search" class="sr-only" data-node-hydration="12">Search</label><div class="relative" data-node-hydration="13"><div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3"><svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="h-5 w-5 text-gray-400"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z"></path></svg></div><button name="search" class="block w-full rounded-md border-0 bg-white py-1.5 pl-10 pr-3 text-gray-400 ring-1 ring-inset ring-gray-300 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6" id="search" data-node-hydration="14,click:1"><div class="h-full my-auto flex flex-row align-middle justify-between"><span class="md:pl-2">Search</span><div class="ml-3 flex-none font-semibold text-gray-500"><kbd class="font-sans">CTRL + /</kbd></div></div></button></div></div></div><div class="flex items-center lg:hidden"><button aria-expanded="false" type="button" aria-controls="mobile-menu" class="relative inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500" data-node-hydration="15,click:1"><span class="absolute -inset-0.5"></span><span class="sr-only">Open main menu</span><svg stroke="currentColor" fill="none" stroke-width="1.5" viewBox="0 0 24 24" aria-hidden="true" class="block h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5" aria-hidden="true" fill="none" class="hidden h-6 w-6"><path stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" stroke-linecap="round"></path></svg></button></div></div></div><div class="lg:hidden hidden" id="mobile-menu" data-node-hydration="16"><div class="space-y-1 pb-3 pt-2"><a href="/" dioxus-prevent-default="onclick" class="block border-l-4 border-transparent py-2 pl-3 pr-4 text-base font-medium text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800" role="menuitem" tabindex="-1" data-node-hydration="17,click:1"><!--node-id18-->Home<!--#--></a><a href="/docs/" dioxus-prevent-default="onclick" class="block border-l-4 border-transparent py-2 pl-3 pr-4 text-base font-medium text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800" role="menuitem" tabindex="-1" data-node-hydration="19,click:1"><!--node-id20-->Docs<!--#--></a></div></div></nav><div class="w-full pt-12 backdrop-blur-lg bg-white/75" style="min-height:100vh;" data-node-hydration="21"><div class="max-w-screen-2xl flex flex-row justify-between mx-auto"><!--placeholder22--><section class="body-font overflow-hidden mx-auto container pt-12 pb-12 md:w-2/3" data-node-hydration="23"><div class="-my-8"><div class="w-full mb-20 flex-wrap list-none rounded-md"><article class="markdown-body pt-1"><h1 id="structured-generation-visualized" data-node-hydration="24"><a href="#structured-generation-visualized" class="header">Structured Generation Visualized</a></h1><p data-node-hydration="25"><img src="/structuredgenerationvisualizedpngb14446e8b56c68a5.png" alt="Structured Generation Visualized" title="" data-node-hydration="26"/></p><p data-node-hydration="27">Text is the universal format for data. The code for this post that communicates with JSON and and renders the result with HTML. Almost every part of that process is visualized with text. LLMs are trained on a giant corpus of web text, so they should be excellent at understanding and writing formats like JSON right? Let&#x27;s try asking a LLM to generate JSON for a character in this format:</p><div style="position: relative;" data-node-hydration="28"><div><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">name</span><span style="color:#c0c5ce;">&quot;: string,
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">description</span><span style="color:#c0c5ce;">&quot;: string,
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">metadata</span><span style="color:#c0c5ce;">&quot;: {
</span><span style="color:#c0c5ce;">        &quot;</span><span style="color:#a3be8c;">age</span><span style="color:#c0c5ce;">&quot;: number,
</span><span style="color:#c0c5ce;">        &quot;</span><span style="color:#a3be8c;">height</span><span style="color:#c0c5ce;">&quot;: number (cm),
</span><span style="color:#c0c5ce;">        &quot;</span><span style="color:#a3be8c;">weight</span><span style="color:#c0c5ce;">&quot;: number (kg),
</span><span style="color:#c0c5ce;">        &quot;</span><span style="color:#a3be8c;">hair_color</span><span style="color:#c0c5ce;">&quot;: string,
</span><span style="color:#c0c5ce;">        &quot;</span><span style="color:#a3be8c;">eye_color</span><span style="color:#c0c5ce;">&quot;: string,
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><p data-node-hydration="29">This should be pretty simple. Let&#x27;s use a small model that is good at structured formats and reasoning called Phi-3-Mini. We can use <a href="https://github.com/floneum/floneum/tree/main/interfaces/kalosm">Kalosm</a> to stream the text:</p><div style="position: relative;" data-node-hydration="30"><div><pre style="background-color:#2b303b;">
<span style="color:#65737e;">// Create a new model. We are using the Phi-3 model which is small and focused on reasoning tasks.
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> model = Llama::phi_3()
</span><span style="color:#c0c5ce;">    .await
</span><span style="color:#c0c5ce;">    .</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Create a task that generates text for a character
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> task = Task::builder(&quot;</span><span style="color:#a3be8c;">You generate data in a JSON format</span><span style="color:#c0c5ce;">&quot;).</span><span style="color:#96b5b4;">build</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Run the task
</span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> result = task.</span><span style="color:#96b5b4;">run</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">r</span><span style="color:#c0c5ce;">#</span><span style="color:#a3be8c;">&quot;Generate a character with this format: { &quot;name&quot;: string, &quot;description&quot;: string, &quot;metadata&quot;: { &quot;age&quot;: number, &quot;height_cm&quot;: number, &quot;weight_kg&quot;: number, &quot;hair_color&quot;: string, &quot;eye_color&quot;: string } }</span><span style="color:#c0c5ce;">&quot;#, &amp;model);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Stream the text into stdout
</span><span style="color:#c0c5ce;">result.</span><span style="color:#96b5b4;">to_std_out</span><span style="color:#c0c5ce;">().await.</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><p data-node-hydration="31">Running the program sometimes generates valid JSON with reasonable data:</p><div style="position: relative;" data-node-hydration="32"><div><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">  &quot;</span><span style="color:#a3be8c;">name</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">Michael Thompson</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">  &quot;</span><span style="color:#a3be8c;">description</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">A dedicated software developer with a passion for coding and innovation. Known amongst friends to be an avid reader, particularly of science fiction novels.</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">  &quot;</span><span style="color:#a3be8c;">metadata</span><span style="color:#c0c5ce;">&quot;: {
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">age</span><span style="color:#c0c5ce;">&quot;: </span><span style="color:#d08770;">29</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">height_cm</span><span style="color:#c0c5ce;">&quot;: </span><span style="color:#d08770;">180</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">weight_kg</span><span style="color:#c0c5ce;">&quot;: </span><span style="color:#d08770;">75</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">hair_color</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">dark brown</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">eye_color</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">blue</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#c0c5ce;">  }
</span><span style="color:#c0c5ce;">}
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><p data-node-hydration="33">But other times, it generates nonsense:</p><div style="position: relative;" data-node-hydration="34"><div><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">   &quot;</span><span style="color:#a3be8c;">name</span><span style="color:#c0c5ce;">&quot;:&quot;</span><span style="color:#a3be8c;">Emily Thompson</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">    &quot;</span><span style="color:#a3be8c;">description</span><span style="color:#c0c5ce;">&quot;:&quot;</span><span style="color:#a3be8c;">A talented graphic designer with an eye-catching style. Emily is known to be creative, friendly and dedicated at her job.</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">     &quot;</span><span style="color:#a3be8c;">metadata</span><span style="color:#c0c5ce;">&quot;: { 
</span><span style="color:#c0c5ce;">         &quot;</span><span style="color:#a3be8c;">age</span><span style="color:#c0c5ce;">&quot;:</span><span style="color:#d08770;">28</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">          &quot;</span><span style="color:#a3be8c;">height</span><span style="color:#c0c5ce;">&quot;:</span><span style="color:#d08770;">165</span><span style="color:#c0c5ce;">,&quot;</span><span style="color:#a3be8c;">cm</span><span style="color:#c0c5ce;">&quot; :</span><span style="color:#d08770;">94</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">           &quot;</span><span style="color:#a3be8c;">weight</span><span style="color:#c0c5ce;">&quot;:&quot;</span><span style="color:#a3be8c;">60</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">kg</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">            &quot;</span><span style="color:#a3be8c;">hair_color</span><span style="color:#c0c5ce;">&quot;:&quot;</span><span style="color:#a3be8c;">blonde</span><span style="color:#c0c5ce;">&quot;,
</span><span style="color:#c0c5ce;">             &quot;</span><span style="color:#a3be8c;">eye_color</span><span style="color:#c0c5ce;">&quot;:&quot;</span><span style="color:#a3be8c;">blue</span><span style="color:#c0c5ce;">&quot; }  
</span><span style="color:#c0c5ce;">}
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><p data-node-hydration="35">Ok, so just asking nicely isn&#x27;t enough... The LLM knows something about the structure of JSON, but it isn&#x27;t consistent enough to generate valid JSON every time.</p><p data-node-hydration="36">We need some way of controlling what the LLM generates to guide it twards our format. First, what exactly does the LLM generate?</p><h2 id="token-generation" data-node-hydration="37"><a href="#token-generation" class="header">Token Generation</a></h2><p data-node-hydration="38">LLM sees text in chunks of tokens. On average, each token is about 2/3 of a word, but depending on the word, it could be the entire word or a single character.</p><p data-node-hydration="39">Let&#x27;s take a look at what tokens look like from the perspective of the LLM. You can see what previous tokens the LLM has seen at the bottom of the visualization and a few of the next possible tokens on the right:</p><!--placeholder40--><div class="w-full flex flex-row justify-center items-center" data-node-hydration="41"><div class="spinner"></div></div><p data-node-hydration="42">To generate text, LLMs assign a probability to each token and pick a token with a high probability. Picking a token from the list of probabilities is called sampling.</p><p data-node-hydration="43">We need to control what tokens the LLM picks after it assigns a probability to each token. Instead of choosing the most likely token, we must look for only tokens that fit our format.</p><h2 id="defining-the-format" data-node-hydration="44"><a href="#defining-the-format" class="header">Defining the Format</a></h2><p data-node-hydration="45">To find tokens that fit our format, we need a parser that:</p><ol data-node-hydration="46"><li>Incrementally parses new text in a way we can roll back. If the current tokens are <code>{&quot;age&quot;:</code> we need to be able to try adding <code>a</code> and if it fails, roll back to <code>{&quot;age&quot;</code>. If our current text is long, our parser shouldn&#x27;t need to re-parse the entire history for every one of the <code>~128,000</code> possible new tokens</li><li>Fails immediately if a new token is invalid. We need to validate every token individually so we don&#x27;t waste time trying a sequence of tokens and then walking back once we realize it&#x27;s invalid</li></ol><p data-node-hydration="47">Regular Expressions are very well suited for this task. We can compute regular expressions with a finite state machine. Each state is cheap to store, generally just a single index into a table. Each transition is cheap to compute, just a lookup into a table.</p><p data-node-hydration="48">Here is a regular expression that matches our JSON schema:</p><div style="position: relative;" data-node-hydration="49"><div><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">\{ &quot;</span><span style="color:#a3be8c;">name</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">[A-Z][a-z]{1,10} [A-Z][a-z]{1,10}</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">description</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">[ A-Za-z]+</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">metadata</span><span style="color:#c0c5ce;">&quot;: \{ &quot;</span><span style="color:#a3be8c;">age</span><span style="color:#c0c5ce;">&quot;: \d{</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">}, &quot;</span><span style="color:#a3be8c;">height_cm</span><span style="color:#c0c5ce;">&quot;: \d{</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">}, &quot;</span><span style="color:#a3be8c;">weight_kg</span><span style="color:#c0c5ce;">&quot;: \d{</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">}, &quot;</span><span style="color:#a3be8c;">hair_color</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">[A-Z][a-z]+</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">eye_color</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">[A-Z][a-z]+</span><span style="color:#c0c5ce;">&quot; \} \}
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><h2 id="constrained-augmented-sampling" data-node-hydration="50"><a href="#constrained-augmented-sampling" class="header">Constrained Augmented Sampling</a></h2><p data-node-hydration="51">Let&#x27;s combine our format with the sampler. We can only sample tokens that fit our regex. Even if you choose completely random options from the list of probabilities, the LLM will still generate text that conforms to the format. From the perspective of the LLM, it looks something like this:</p><!--placeholder52--><div class="w-full flex flex-row justify-center items-center" data-node-hydration="53"><div class="spinner"></div></div><p data-node-hydration="54">Lets see what our LLM generates with our new constraints:</p><div style="position: relative;" data-node-hydration="55"><div><pre style="background-color:#2b303b;">
<span style="color:#65737e;">// Create a new model. We are using the Phi-3 model, a small and focused on reasoning tasks.
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> model = Llama::phi_3()
</span><span style="color:#c0c5ce;">    .await
</span><span style="color:#c0c5ce;">    .</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Create a constraint that checks if the generated text is valid JSON
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> constraint = RegexParser::new(</span><span style="color:#b48ead;">r</span><span style="color:#c0c5ce;">#</span><span style="color:#a3be8c;">&quot;\{ &quot;name&quot;: &quot;[A-Z][a-z]{1,10} [A-Z][a-z]{1,10}&quot;, &quot;description&quot;: &quot;[ A-Za-z]+&quot;, &quot;metadata&quot;: \{ &quot;age&quot;: \d{1,2}, &quot;height_cm&quot;: \d{1,3}, &quot;weight_kg&quot;: \d{1,3}, &quot;hair_color&quot;: &quot;[A-Z][a-z]+&quot;, &quot;eye_color&quot;: &quot;[A-Z][a-z]+&quot; \} \}</span><span style="color:#c0c5ce;">&quot;#).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#65737e;">// Create a task that generates text for a character
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> task = Task::builder(&quot;</span><span style="color:#a3be8c;">You generate data in a JSON format</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">    .</span><span style="color:#96b5b4;">with_constraints</span><span style="color:#c0c5ce;">(constraint)
</span><span style="color:#c0c5ce;">    .</span><span style="color:#96b5b4;">build</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Run the task
</span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> result = task.</span><span style="color:#96b5b4;">run</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">r</span><span style="color:#c0c5ce;">#</span><span style="color:#a3be8c;">&quot;Generate a character with this format: { &quot;name&quot;: string, &quot;description&quot;: string, &quot;metadata&quot;: { &quot;age&quot;: number, &quot;height_cm&quot;: number, &quot;weight_kg&quot;: number, &quot;hair_color&quot;: string, &quot;eye_color&quot;: string } }</span><span style="color:#c0c5ce;">&quot;#, &amp;model);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Stream the text into stdout
</span><span style="color:#c0c5ce;">result.</span><span style="color:#96b5b4;">to_std_out</span><span style="color:#c0c5ce;">().await.</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><p data-node-hydration="56">The results are much more consistent. The LLM always generates valid JSON because of the constraints. It also generates JSON in a more precise format because we specified everything about the format we wanted. It knows we need exactly two words that start with a capital letter for the name.</p><div style="position: relative;" data-node-hydration="57"><div><pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">{ &quot;</span><span style="color:#a3be8c;">name</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">Evelyn Archer</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">description</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">A cunning and resourceful detective with a sharp eye for detail who has solved numerous complex cases in the bustling city of New York during her prime years as an investigator at midlife crisis stage when she starts to question life choices leading up until now that age is just another number</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">metadata</span><span style="color:#c0c5ce;">&quot;: { &quot;</span><span style="color:#a3be8c;">age</span><span style="color:#c0c5ce;">&quot;: </span><span style="color:#d08770;">45</span><span style="color:#c0c5ce;">, &quot;</span><span style="color:#a3be8c;">height_cm</span><span style="color:#c0c5ce;">&quot;: </span><span style="color:#d08770;">168</span><span style="color:#c0c5ce;">, &quot;</span><span style="color:#a3be8c;">weight_kg</span><span style="color:#c0c5ce;">&quot;: </span><span style="color:#d08770;">70</span><span style="color:#c0c5ce;">, &quot;</span><span style="color:#a3be8c;">hair_color</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">Auburn</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">eye_color</span><span style="color:#c0c5ce;">&quot;: &quot;</span><span style="color:#a3be8c;">Hazel</span><span style="color:#c0c5ce;">&quot; } }
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><h2 id="accelerated-structured-generation" data-node-hydration="58"><a href="#accelerated-structured-generation" class="header">Accelerated Structured Generation</a></h2><p data-node-hydration="59">You may have noticed that in some positions, the LLM only has one valid token choice. We don&#x27;t actually need to run the LLM in these cases. Instead, we can choose the next token directly.</p><p data-node-hydration="60">In practice, this acts a bit like autocomplete. Once the LLM starts generating a specific part of the grammar, the rest of the chunk gets filled in automatically:</p><!--placeholder61--><div class="w-full flex flex-row justify-center items-center" data-node-hydration="62"><div class="spinner"></div></div><p data-node-hydration="63">Instead of choosing each of the ~16 tokens, we only need to choose between the ~4 interesting tokens!</p><p data-node-hydration="64">The LLM will still need to read the new text, but that process is much faster than determining the probabilities for the next token.</p><h2 id="beyond-regex" data-node-hydration="65"><a href="#beyond-regex" class="header">Beyond REGEX</a></h2><p data-node-hydration="66">REGEX is great for simple constraints, but it is both tedious to write and limited to simple patterns. There are some structures you just can&#x27;t express with REGEX. For example, you can&#x27;t use REGEX to validate any recursive structures, including the general version of JSON itself!</p><p data-node-hydration="67">Let&#x27;s take a look at two alternative approaches to validating text: Deriving parsers automatically and writing custom validators.</p><h3 id="deriving-parsers" data-node-hydration="68"><a href="#deriving-parsers" class="header">Deriving Parsers</a></h3><p data-node-hydration="69">If you don&#x27;t need complete control over the syntax the model uses to generate JSON, you can just derive a parser for JSON from a type:</p><div style="position: relative;" data-node-hydration="70"><div><pre style="background-color:#2b303b;">
<span style="color:#65737e;">// Cargo.toml
</span><span style="color:#65737e;">// [dependencies]
</span><span style="color:#65737e;">// kalosm = { version = &quot;0.3&quot;, features = [&quot;language&quot;, &quot;metal&quot;] }
</span><span style="color:#65737e;">// tokio = { version = &quot;1.37.0&quot;, features = [&quot;full&quot;] }
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">kalosm::language::*;
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Define a type for the character
</span><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">derive</span><span style="color:#c0c5ce;">(Parse)]
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">Character {
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">name</span><span style="color:#c0c5ce;">: String,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">description</span><span style="color:#c0c5ce;">: String,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">metadata</span><span style="color:#c0c5ce;">: Metadata,
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// Define a type for the metadata
</span><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">derive</span><span style="color:#c0c5ce;">(Parse)]
</span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">Metadata {
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// You can easily set ranges for numbers. In regex this would need to be `100|\d\d|[1-9]`
</span><span style="color:#c0c5ce;">    #[parse(with = </span><span style="color:#bf616a;">U8Parser</span><span style="color:#c0c5ce;">::new(1..=100))]
</span><span style="color:#c0c5ce;">    age: </span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">height_cm</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">weight_kg</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">hair_color</span><span style="color:#c0c5ce;">: String,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">eye_color</span><span style="color:#c0c5ce;">: String,
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">tokio</span><span style="color:#c0c5ce;">::</span><span style="color:#bf616a;">main</span><span style="color:#c0c5ce;">]
</span><span style="color:#c0c5ce;">async </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// Create a new model. We are using the Phi-3 model which is small and focused on reasoning tasks.
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> model = Llama::phi_3()
</span><span style="color:#c0c5ce;">        .await
</span><span style="color:#c0c5ce;">        .</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// Create a constraint that parses our character type
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> constraint = Character::new_parser();
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// Create a task that generates text for a character
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> task = Task::builder(&quot;</span><span style="color:#a3be8c;">You generate data in a JSON format</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">        .</span><span style="color:#96b5b4;">with_constraints</span><span style="color:#c0c5ce;">(constraint)
</span><span style="color:#c0c5ce;">        .</span><span style="color:#96b5b4;">build</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// Run the task
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> result = task.</span><span style="color:#96b5b4;">run</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">r</span><span style="color:#c0c5ce;">#</span><span style="color:#a3be8c;">&quot;Generate a character with this format: { &quot;name&quot;: string, &quot;description&quot;: string, &quot;metadata&quot;: { &quot;age&quot;: number, &quot;height_cm&quot;: number, &quot;weight_kg&quot;: number, &quot;hair_color&quot;: string, &quot;eye_color&quot;: string } }</span><span style="color:#c0c5ce;">&quot;#, &amp;model);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// Stream the text into stdout
</span><span style="color:#c0c5ce;">    result.</span><span style="color:#96b5b4;">to_std_out</span><span style="color:#c0c5ce;">().await.</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// BONUS: Parsing is validation. If you derive a parser, you automatically get out parsed data!
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> parsed: Parsed = result.</span><span style="color:#96b5b4;">parse</span><span style="color:#c0c5ce;">().await.</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">}
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><!--placeholder71--><div class="w-full flex flex-row justify-center items-center" data-node-hydration="72"><div class="spinner"></div></div><h3 id="creating-custom-parsers" data-node-hydration="73"><a href="#creating-custom-parsers" class="header">Creating Custom Parsers</a></h3><p data-node-hydration="74">You can create your own parser for more control over what the model generates. Unlike regex, your parser can parse languages that <a href="https://github.com/ealmloff/html-parser">require context like html</a>.</p><p data-node-hydration="75">Regular languages are limited to patterns parsable with a set number of states. Recursive structures like HTML require an unbounded stack to keep track of the current depth of the HTML. In Kalosm, you can implement a custom parser to parse any language with an arbitrary number of states.</p><div style="position: relative;" data-node-hydration="76"><div><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">kalosm::language::*;
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">tokio</span><span style="color:#c0c5ce;">::</span><span style="color:#bf616a;">main</span><span style="color:#c0c5ce;">]
</span><span style="color:#c0c5ce;">async </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> model = Llama::phi_3().await.</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> task = Task::builder(&quot;</span><span style="color:#a3be8c;">The assistant generates plain HTML</span><span style="color:#c0c5ce;">&quot;)
</span><span style="color:#c0c5ce;">        .</span><span style="color:#96b5b4;">with_constraints</span><span style="color:#c0c5ce;">(
</span><span style="color:#c0c5ce;">            html_parser::Element::new_parser()
</span><span style="color:#c0c5ce;">        )
</span><span style="color:#c0c5ce;">        .</span><span style="color:#96b5b4;">build</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> input = </span><span style="color:#96b5b4;">prompt_input</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">&gt; </span><span style="color:#c0c5ce;">&quot;).</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> output = task.</span><span style="color:#96b5b4;">run</span><span style="color:#c0c5ce;">(input, &amp;model);
</span><span style="color:#c0c5ce;">    output.</span><span style="color:#96b5b4;">to_std_out</span><span style="color:#c0c5ce;">().await.</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> html: html_parser::Element = output.await.</span><span style="color:#96b5b4;">unwrap</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    println!();
</span><span style="color:#c0c5ce;">    println!(&quot;</span><span style="color:#d08770;">{:#?}</span><span style="color:#c0c5ce;">&quot;, html);
</span><span style="color:#c0c5ce;">}
</span></pre>
</div><button style="position: absolute; top: 0; right: 0; background: rgba(0, 0, 0, 0.75); color: white; border: 1px solid white; padding: 0.25em;" onclick="navigator.clipboard.writeText(this.previousElementSibling.innerText)">Copy</button></div><p data-node-hydration="77">Because parsing runs in native rust code, you can parse even complex languages like HTML with constraints for elements, attributes, and values in real-time:</p><!--placeholder78--><div class="w-full flex flex-row justify-center items-center" data-node-hydration="79"><div class="spinner"></div></div><h2 id="sampler-aware-structured-generation" data-node-hydration="80"><a href="#sampler-aware-structured-generation" class="header">Sampler Aware Structured Generation</a></h2><p data-node-hydration="81">We are currently running the parser for every one of the 128,000 tokens every time we add a new token to the sequence. That wasn&#x27;t an issue for REGEX where each new token is only a lookup away, but it can be slow for more complex parsers.</p><p data-node-hydration="82">Instead of running the parser for every token, we can use the structure of the sampler to skip parsing some tokens.</p><p data-node-hydration="83">There are generally a few steps between the token probabilities after constraints and the token that gets chosen. Each of those steps that modify the probabilities of the tokens is called a sampler. The top-k sampler is one of the most common samplers. It only samples the top k most likely tokens. Here is what that could look like if we only keep the top 2 tokens (where k=2):</p><p data-node-hydration="84"><img src="/topksamplingpng70e96329baf4c4d3.png" alt="Top-k Sampling" title="" data-node-hydration="85"/></p><blockquote data-node-hydration="86"><p>Generally, k is larger, but much smaller than the number of tokens in the model. The default in kalosm is 64.</p></blockquote><p data-node-hydration="87">Instead of parsing every token, we can skip parsing tokens once we find once we find the most probable k tokens. Since the LLM knows about the constraints, the valid tokens tend to have a very high probability so we can skip parsing the majority of the 128,000 tokens.</p><p data-node-hydration="88"><img src="/topkacceleratedstructuredgenerationpnge944b64bea3fee5c.png" alt="Top-K Accelerated Structured Generation" title="" data-node-hydration="89"/></p><h2 id="conclusion" data-node-hydration="90"><a href="#conclusion" class="header">Conclusion</a></h2><p data-node-hydration="91">Structured generation gives you fine-grained control of generation while accelerating generation speed. More consistent outputs make it possible to use LLMs with typed APIs or guide LLMs along a longer multi-step process. I hope you found the visualizations useful. I would love to hear what use cases you have for structured generation.</p><p data-node-hydration="92">If you need a complex structured generation parser, try <a href="https://floneum.com/kalosm">Kalosm</a>. You can write your parsers in Rust which means they run extremely fast. For parsers that can run up to a quarter million times per token, slow is not an option. Or join the <a href="https://discord.gg/dQdmhuB8q5">discord</a> to discuss this article.</p></article></div></div></section><div class="hidden xl:sticky xl:top-[4.75rem] xl:-mr-6 xl:block xl:h-[calc(100vh-4.75rem)] xl:flex-none xl:overflow-y-auto xl:py-16 xl:pr-6" data-node-hydration="93"><nav aria-labelledby="on-this-page-title" class="w-56"><h2 id="on-this-page-title" class="font-display text-sm font-medium text-slate-900" data-node-hydration="94">On this page</h2><ol role="list" class="mt-4 space-y-3 text-sm" data-node-hydration="95"><li class="pb-2 pl-2" data-node-hydration="96"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#structured-generation-visualized" data-node-hydration="97"><!--node-id98-->Structured Generation Visualized<!--#--></a></h3></li><li class="pb-2 pl-4" data-node-hydration="99"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#token-generation" data-node-hydration="100"><!--node-id101-->Token Generation<!--#--></a></h3></li><li class="pb-2 pl-4" data-node-hydration="102"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#defining-the-format" data-node-hydration="103"><!--node-id104-->Defining the Format<!--#--></a></h3></li><li class="pb-2 pl-4" data-node-hydration="105"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#constrained-augmented-sampling" data-node-hydration="106"><!--node-id107-->Constrained Augmented Sampling<!--#--></a></h3></li><li class="pb-2 pl-4" data-node-hydration="108"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#accelerated-structured-generation" data-node-hydration="109"><!--node-id110-->Accelerated Structured Generation<!--#--></a></h3></li><li class="pb-2 pl-4" data-node-hydration="111"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#beyond-regex" data-node-hydration="112"><!--node-id113-->Beyond REGEX<!--#--></a></h3></li><li class="pb-2 pl-4" data-node-hydration="114"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#sampler-aware-structured-generation" data-node-hydration="115"><!--node-id116-->Sampler Aware Structured Generation<!--#--></a></h3></li><li class="pb-2 pl-4" data-node-hydration="117"><h3><a class="font-normal text-slate-500 hover:text-slate-700" href="#conclusion" data-node-hydration="118"><!--node-id119-->Conclusion<!--#--></a></h3></li></ol></nav></div></div></div><footer class="bg-white" data-node-hydration="120"><div class="mx-auto max-w-7xl overflow-hidden px-6 py-20 sm:py-24 lg:px-8"><nav aria-label="Footer" class="-mb-6 columns-2 sm:flex sm:justify-center sm:space-x-12"><div class="pb-6" data-node-hydration="121"><a href="/" dioxus-prevent-default="onclick" class="text-sm leading-6 text-gray-600 hover:text-gray-900" data-node-hydration="122,click:1"><!--node-id123-->About<!--#--></a></div><div class="pb-6" data-node-hydration="124"><a href="/docs/" dioxus-prevent-default="onclick" class="text-sm leading-6 text-gray-600 hover:text-gray-900" data-node-hydration="125,click:1"><!--node-id126-->Docs<!--#--></a></div><div class="pb-6" data-node-hydration="127"><a href="/blog/" dioxus-prevent-default="onclick" class="text-sm leading-6 text-gray-600 hover:text-gray-900" data-node-hydration="128,click:1"><!--node-id129-->Blog<!--#--></a></div></nav><div class="mt-10 flex justify-center space-x-10"><a href="https://github.com/floneum/floneum/tree/main/floneum/floneum" dioxus-prevent-default="" class="text-gray-400 hover:text-gray-500" rel="noopener noreferrer" data-node-hydration="130,click:1"><span class="sr-only" data-node-hydration="131">Github</span><svg class="h-6 w-6" viewBox="0 0 24 24" aria-hidden="true" data-node-hydration="132"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" fill="currentColor" fill-rule="nonzero"></path></svg></a><a href="https://discord.gg/dQdmhuB8q5" dioxus-prevent-default="" class="text-gray-400 hover:text-gray-500" rel="noopener noreferrer" data-node-hydration="133,click:1"><span class="sr-only" data-node-hydration="134">Discord</span><svg class="h-6 w-6" viewBox="0 -28.5 256 256" preserveAspectRatio="xMidYMid" aria-hidden="true" data-node-hydration="135"><path d="M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z" fill="currentColor" fill-rule="nonzero"></path></svg></a></div></div></footer><script>window.initial_dioxus_hydration_data="hYEY9YEY9YEY9YEY9YEY9Q==";</script>
  </div>
  <script>
    window.addEventListener('scroll', () => {
      let scrollTop = window.scrollY;
      let winHeight = window.document.documentElement.scrollHeight - window.document.documentElement.clientHeight;
      let new_scroll = Math.min(Math.max(scrollTop, 0) / Math.max(winHeight, 1), 1);

      document.body.style.setProperty('--scroll', new_scroll);
    }, false);
  </script>
<script>
            // We can't use a module script here because we need to start the script immediately when streaming
            import("/./assets/dioxus/floneum-site.js").then(
                ({ default: init }) => {
                init("/./assets/dioxus/floneum-site_bg.wasm").then((wasm) => {
                    if (wasm.__wbindgen_start == undefined) {
                    wasm.main();
                    }
                });
                }
            );
            </script>
            
            </body>

</html>